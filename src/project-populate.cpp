/// @copyright See `LICENSE` in the root directory of this project.

#include <antler/project/project.hpp>
#include "cmake.hpp"

#include <filesystem>
#include <fstream>

namespace antler::project {

namespace { // anonymous

const std::filesystem::path cmake_lists{"CMakeLists.txt"};
constexpr std::string_view magic            = "#antler-proj::generated";
constexpr std::string_view comment_preamble = "# This file was AUTOGENERATED and is maintained using antler-proj tools.\n"
                                              "#   Modification or removal of the above line will cause antler-proj to skip this line.\n"
                                              "#   Any changes made to this file will be lost when any antler-proj tool updates this project.";

/// Test to see if a file has the magic maintenance string.
/// @return true if the file either does NOT exist OR contains the magic
[[nodiscard]] bool has_magic(const std::filesystem::path& path, std::ostream& error_stream = std::cerr) {

   if (!std::filesystem::exists(path))
      return true;

   // search path for magic1.
   std::ifstream ifs(path);
   if (!ifs.is_open()) {
      error_stream << "Failed to open " << path << "\n";
      return false;
   }

   std::array<char, magic.size()> buffer{};

   ifs.read(buffer.data(), buffer.size());

   return memcmp(buffer.data(), magic.data(), buffer.size()) == 0;
}


} // anonymous namespace


bool project::populate(bool replace, std::ostream& error_stream) noexcept {

   // Sanity check: ensure path is valid.
   if (m_path.empty()) {
      error_stream << "Can not populate a project without a path.\n";
      return false;
   }

   // Find the project path, and make sure the subdirs/project directory tree exists.
   auto project_path = m_path.parent_path();
   if (!init_dirs(project_path, false, error_stream)) // expect_empty is `false`, it's okay if everthing exists.
      return false;                                   // But its not okay if the filesystem doesn't already exist AND can't be created.

   // Check to see if the top level cmake file needs to be created.
   {
      auto path = project_path / cmake_lists;
      bool create = true;
      if (!replace && std::filesystem::exists(path)) {
         // Look to see if the header contains the magic, if it does we will not create the file.
         create = has_magic(path);
      }
      if (create) {
         std::ofstream ofs(path);
         if (!ofs.good()) {
            error_stream << "Can not open path for writing: << " << path << "\n";
         }
         else {
            try {
               ofs
                  << project::magic_comment << "\n"
                  << comment_preamble << "\n"
                  //<< //(m_ver.is_semver() ? cmake::project(m_name) : cmake::project(m_name, static_cast<semver>(m_ver)) )
                  << "\n"
                  //<< cmake::add_subdirectory("libs")
                  //<< cmake::add_subdirectory("apps")
                  << "\n"
                  << "option(BUILD_TESTS \"Build and run the tests.\" On)\n"
                  << "if(BUILD_TESTS)\n"
                  << "   enable_testing()\n"
                  //<< "   " << cmake::add_subdirectory("tests")
                  << "endif()\n"
                  ;
            }
            catch(std::exception& e) {
               error_stream << "Error writing to " << path << ": " << e.what() << "\n";
               return false;
            }
            catch(...) {
               error_stream << "Error writing to " << path << ": UNKNOWN\n";
               return false;
            }
         }
      }
   }



   // At each level we are going to want to create a CMakeLists.txt file and zero or more `.cmake` include files.

   // Each file includes a header indicating the user should not modify it. And if they do, changes will be lost unless they
   // delete this line; however, if they delete the line, auto updates will no longer be possible.

   // Then we update everything.



   // Finally CMake the project. Ensure the output goes to a log file.



   return false;
}


} // namespace antler::project
